<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Vif, a simple webserver in OCaml</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Vif, a simple webserver in OCaml</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="vif-a-simple-webserver-in-ocaml"><a class="header" href="#vif-a-simple-webserver-in-ocaml">Vif, a simple webserver in OCaml</a></h1>
<p>Vif is a small program that allows you to initiate a web server (<a href="https://github.com/robur-coop/ocaml-h1">http/1.1</a>
&amp; <a href="https://github.com/anmonteiro/ocaml-h2">h2</a>) from an OCaml script:</p>
<pre><code class="language-shell">$ opam install vif
$ cat &gt;main.ml &lt;&lt;EOF
#require "vif" ;;
open Vif ;;

let default req _server () =
  let str = "Hello World!\n" in
  let* () = Response.with_string req str in
  Response.respond `OK
;;

let routes =
  let open Vif.U in
  let open Vif.R in
  let open Vif.T in
  [ get (rel /?? nil) --&gt; default ]
;;

let () = Miou_unix.run @@ fun () -&gt;
  Vif.run routes ()
;;
EOF
$ vif main.ml --pid vif.pid &amp;
[1] 1337
$ curl http://localhost:8080/
Hello World!
$ kill -SIGINT $(cat vif.pid)
</code></pre>
<p>The aim is to have a small web server for cheap and to be able to iterate on it
quickly without necessarily having a workflow that involves compiling and
executing an OCaml project. The OCaml script is executed by <code>vif</code> just as it
could be executed by <code>ocaml</code> and it describes what your webserver should do.</p>
<p>In this short tutorial, we will see how to use Vif to implement more or less
complex web services.</p>
<h2 id="vif-as-a-library"><a class="header" href="#vif-as-a-library">Vif as a library</a></h2>
<p>Of course, vif is also a library. You don't need to write an OCaml script to
get a web server. You can also develop your own application and compile it with
Vif to get an executable that will be your web server.</p>
<p>However, in terms of iterations, the loop <em>ocaml script → web server test</em> is
faster than <em>ocaml program → compilation → web server test</em>.</p>
<h2 id="how-to-install-vif"><a class="header" href="#how-to-install-vif">How to install Vif</a></h2>
<p>Vif is available on opam. You can install it using the command:</p>
<pre><code class="language-shell">$ opam install vif
</code></pre>
<p>You can also obtain the development version of Vif via:</p>
<pre><code class="language-shell">$ opam pin add https://git.robur.coop/robur/vif.git
</code></pre>
<p>The Vif project is hosted on our server <a href="https://git.robur.coop">git.robur.coop</a>. You
can also access a mirror on <a href="https://github.com/robur-coop/vif">GitHub</a>. Issues
and pull requests can be proposed on both repositories (pull requests will be
merged into our cooperative's repository).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-first-vif-application"><a class="header" href="#my-first-vif-application">My first Vif application</a></h1>
<p>To understand Vif, we will iterate several times on a small project whose goal
is to implement a website with a user area. This goal will allow us to see the
main features of Vif. To do this, we will also use <code>hurl</code>, an HTTP client in
OCaml that uses the same libraries as Vif. The latter will allow us to inspect
a whole host of details regarding requests, responses and cookies.</p>
<p>Let's start by installing <code>vif</code> and <code>hurl</code> using <code>opam</code>. Next, we will create a
folder and work in it to develop our brand new website.</p>
<pre><code class="language-shell">$ opam install vif
$ opam install hurl
$ mkdir my-first-vif-application
$ cd my-first-vif-application
</code></pre>
<p>Vif is a library, but we also offer a small program that allows you to run an
OCaml script and launch an HTTP server. This approach has the advantage of
avoiding the "development, compilation, testing" loop (as is the case with
native languages) and focusing primarily on development and testing.</p>
<p>We will come back to the <code>vif</code> tool, the library and the different ways of using
this project in more detail later, but for now let's focus on developing our
website.</p>
<h2 id="my-first-webpage-with-vif"><a class="header" href="#my-first-webpage-with-vif">My first webpage with Vif</a></h2>
<p>We are therefore going to create an OCaml script in which we will develop our
website:</p>
<pre><code class="language-shell">$ cat &gt;main.ml &lt;&lt;EOF
#require "vif" ;;

let () = Miou_unix.run @@ fun () -&gt; Vif.run [] () ;;
EOF
$ vif --pid vif.pid main.ml &amp;
$ hurl http://localhost:8080/
HTTP/1.1 404 Not Found

connection: close
content-length: 120
content-length: 120
content-type: text/plain; charset=utf-8

Unspecified destination / (GET):
user-agent: hurl/0.0.1
host: localhost
connection: close
content-length: 0
$ kill -SIGINT $(cat vif.pid)
</code></pre>
<p>Here, we write a new file called <code>main.ml</code>, which will simply launch the
<a href="https://github.com/robur-coop/miou">Miou</a> scheduler and the Vif server. We then run this script using <code>vif</code>
and make an HTTP request using <code>hurl</code> to obtain a response. Finally, we <code>kill</code>
the Vif server.</p>
<p>The Vif server responded with a 404 (<em>not found</em>) response because no routes are
defined, and it also describes the request it just received. We will therefore
add a route for our website.</p>
<pre><code class="language-ocaml">#require "vif" ;;

let index req _server () =
  let open Vif.Response.Syntax in
  let str = "Hello World!\n" in
  let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
  let* () = Vif.Response.with_string req str in
  Vif.Response.respond `OK
;;

let routes =
  let open Vif.Uri in
  let open Vif.Route in
  [ get (rel /?? any) --&gt; index ]
;;

let () = Miou_unix.run @@ fun () -&gt;
  Vif.run routes () ;;
</code></pre>
<pre><code class="language-shell">$ vif --pid vif.pid main.ml &amp;
$ hurl https://localhost:8080/
HTTP/1.1 200 OK

connection: close
content-length: 13
content-type: text/plain; charset=utf-8

Hello World!
$ kill -SIGINT $(cat vif.pid)
</code></pre>
<p>And here is our first page with Vif! We have added a new <code>index</code> function that
will process the request and provide a response. In this response, we will
write <code>"Hello World!"</code> and send it with the code 200 (<code>`OK</code>). We can see
that this is indeed what the server responds when we use <code>hurl</code>.</p>
<p>This <code>index</code> function will be associated with a route <code>get (rel /?? any)</code>. This
route allows us to filter requests and specify that the <code>index</code> function will
only process GET requests with the path <code>"/"</code>.</p>
<h2 id="routes"><a class="header" href="#routes">Routes</a></h2>
<p>The principle behind routes is fairly simple to understand: it allows you to
associate (<code>--&gt;</code>) a path on your website with a function that will process the
request and respond. What Vif brings to the table is the ability to <em>type</em>
routes. Another frequently requested route feature is the ability to specify
<em>holes</em> in the path, which would be values provided by the user.</p>
<p>For example, we would like a route in which the user could specify the name:</p>
<pre><code class="language-ocaml">#require "vif" ;;

let hello req (name : string) _server () =
  let open Vif.Response.Syntax in
  let str = Fmt.str "Hello %S!\n" name in
  let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
  let* () = Vif.Response.with_string req str in
  Vif.Response.respond `OK
;;

let user req (uid : int) _server () =
  let open Vif.Response.Syntax in
  let str = Fmt.str "User %d!\n" uid in
  let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
  let* () = Vif.Response.with_string req str in
  Vif.Response.respond `OK
;;

let routes =
  let open Vif.Uri in
  let open Vif.Route in
  [ get (rel / "hello" /% string `Path /?? any) --&gt; hello
  ; get (rel / "user" /% int /?? any) --&gt; user ]
;;

let () = Miou_unix.run @@ fun () -&gt;
  Vif.run routes () ;;
</code></pre>
<pre><code class="language-shell">$ hurl http://localhost:8080/hello/robur -p b
Hello "robur"!
$ hurl http://localhost:8080/user/42 -p b
User 42!
$ hurl http://localhost:8080/user/robur -p b
Unspecified destination /user/robur (GET):
...
</code></pre>
<p>As we can see, it is possible to define "holes" in our routes with Vif and
obtain their value in the functions associated with these routes. It is also
possible to <em>type</em> these holes so that you only process a certain type of
information, such as an integer (as is the case for our second <code>user</code> function).
Vif will then not only recognise integers, but also transform the value into a
real OCaml integer that you can manipulate.</p>
<p>It is possible to define more complex "holes" that must match a regular
expression. Here is an example where we would like to recognise certain fruits
in our route.</p>
<pre><code class="language-ocaml">#require "vif" ;;

type fruit =
  | Apple
  | Orange
  | Banana
;;

let pp ppf = function
  | Apple -&gt; Fmt.string ppf "Apple"
  | Orange -&gt; Fmt.string ppf "Orange"
  | Banana -&gt; Fmt.string ppf "Banana"
;;

let fruit =
  let v = Tyre.regex Re.(alt [ str "apple"; str "orange"; str "banana" ]) in
  let inj = function
    | "apple" -&gt; Apple
    | "orange" -&gt; Orange
    | "banana" -&gt; Banana
    | _ -&gt; assert false in
  let prj = function
    | Apple -&gt; "apple"
    | Orange -&gt; "orange"
    | Banana -&gt; "banana" in
  Vif.Uri.conv inj prj v
;;

let like req (fruit : fruit) _server () =
  let open Vif.Response.Syntax in
  let str = Fmt.str "I like %a!\n" pp fruit in
  let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
  let* () = Vif.Response.with_string req str in
  Vif.Response.respond `OK
;;

let routes =
  let open Vif.Uri in
  let open Vif.Route in
  [ get (rel /% fruit /?? any) --&gt; like ]
;;

let () = Miou_unix.run @@ fun () -&gt;
  Vif.run routes () ;;
</code></pre>
<pre><code class="language-shell">$ hurl http://localhost:8080/orange -p b
I like Orange!
$ hurl http://localhost:8080/cherries -p b
Unspecified destination /cherries (GET):
...
</code></pre>
<p>Here we describe how to recognise certain fruits using a regular expression
(and thanks to the <a href="https://github.com/ocaml/re"><code>re</code></a> library). Next, we describe how to convert
recognised strings into OCaml values (<code>inj</code> ). Finally, we use this new value in
our route in order to recognise only the specified fruits.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next steps</a></h2>
<p>At this point, you should have a basic understanding of how routes work with
Vif. The next step is to create our user space. This essentially consists of
two routes:</p>
<ul>
<li>a route for submitting user credentials to the server</li>
<li>a route reserved for logged-in users</li>
</ul>
<p>First, we will focus on the server-side mechanics of credential verification.
These credentials will initially be submitted using JSON.</p>
<p>Next, we will introduce the concept of cookies and middleware, which will allow
us to create our second route (accessible only to logged-in users).</p>
<p>Finally, we will enhance this foundation with other features offered by Vif.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-basic-userspace"><a class="header" href="#my-basic-userspace">My basic userspace</a></h1>
<p>Vif implements the basics of web frameworks. It offers middleware and cookie
features, among others. In this chapter, we will use Vif's routing system to
see how to implement a user space. We will essentially create two routes:</p>
<ul>
<li>a route that allows users to submit their login details</li>
<li>a route that should only be accessible to users</li>
</ul>
<p>As for the first route, since it involves submitting identifiers, it will be a
POST route. In the previous chapter, it was possible to <em>type</em> routes, but Vif
is also capable of typing the content of requests. In this case, we will create
a POST route that expects content in JSON format (which will be the user's
identifiers).</p>
<h2 id="jsont--vif"><a class="header" href="#jsont--vif"><code>jsont</code> &amp; Vif</a></h2>
<p>Vif uses the <a href="https://github.com/dbuenzli/jsont"><code>jsont</code></a> library to obtain a DSL for describing
information in JSON format. The aim here is to describe a type (the
identifiers) and describe its equivalent in JSON format using <code>jsont</code>.</p>
<pre><code class="language-ocaml">type credentials =
  { username : string 
  ; password : string }
;;

let credentials =
  let open Jsont in
  let username = Object.mem "username" string in
  let password = Object.mem "password" string in
  let fn username password =
    { username; password } in
  Object.map fn
  |&gt; username
  |&gt; password
  |&gt; Object.finish
;;
</code></pre>
<p>Thanks to the <code>credentials</code> value, we can now serialise and deserialise JSON
and obtain an OCaml value of type <code>credentials</code>. Vif is capable of handling
this type of value in order to deserialise the content of a request itself as
soon as it recognises the content type <code>application/json</code>.</p>
<pre><code class="language-ocaml">let login req _server () =
  let open Vif.Response.Syntax in
  match Vif.Request.of_json req with
  | Ok (v : credentials) -&gt;
    let str = Fmt.str "username: %S, password: %S\n"
      v.username v.password in
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let* () = Vif.Response.with_string req str in
    Vif.Response.respond `OK
  | Error (`Msg msg) -&gt;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let str = Fmt.str "Invalid JSON: %s\n" msg in
    let* () = Vif.Response.with_string req str in
    Vif.Response.respond (`Code 422)
;;

let routes =
  let open Vif.Uri in
  let open Vif.Route in
  let open Vif.Type in
  [ post (json_encoding credentials) (rel /?? nil) --&gt; login ]
;;

let () = Miou_unix.run @@ fun () -&gt;
  Vif.run routes () ;;
</code></pre>
<p>Here's how to send a JSON request using <code>hurl</code>:</p>
<pre><code class="language-shell">$ hurl -m POST http://localhost:8080/ username=robur password=42 -p b
username: "robur", password: "42"
$ hurl -m POST http://localhost:8080/ foo=bar
HTTP/1.1 422 

connection: close
content-length: 122
content-type: text/plain; charset=utf-8

Invalid JSON: Missing members in object:
 password
 username
</code></pre>
<p>In this example, we have specified that our route expects content in JSON
format. Next, Vif uses <code>jsont</code> to attempt to deserialise the given JSON to the
OCaml value <code>credentials</code>. If it fails, we return code 422; otherwise, we
display the information.</p>
<p>The goal here is that serialisation and deserialisation can be seen as a fairly
repetitive task for the user. In this case, Vif handles two formats: JSON using
<code>jsont</code> and <code>multipart/form-data</code>, which we will see in another chapter. These
are the two most commonly used formats with the HTTP protocol, and Vif therefore
handles these formats <em>natively</em>, providing you with a simple way to deserialise
them into OCaml values.</p>
<h2 id="vif-and-cookies"><a class="header" href="#vif-and-cookies">Vif and cookies</a></h2>
<p>When a user logs in, we want to keep the information on the user's side so that
they remain logged in. We therefore want to store this information and also
secure it. We will use Vif to create a new cookie, which will contain a JSON
Web Token (<a href="https://en.wikipedia.org/wiki/JSON_Web_Token">JWT</a>) that ensures the information is secure.</p>
<p>The JWT requires a <em>secret</em>, a value that only the server knows in order to
encrypt/decrypt the JWT. This is where we introduce three concepts:</p>
<ul>
<li>Vif's ability to load an external library (we will use <a href="https://github.com/sporto/jwto">jwto</a>, an
implementation of JWT in OCaml)</li>
<li>the ability to obtain configuration values (often found in the <code>.env</code> file of
a website)</li>
<li>the creation of a new cookie if the user has logged in successfully</li>
</ul>
<pre><code class="language-ocaml">#require "jwto" ;;

type env =
  { secret : string }
;;

let verify { username; password } =
  match username, password with
  | "robur", "42" -&gt; true
  | _ -&gt; false
;;

let login req server { secret } =
  let open Vif.Response.Syntax in
  match Vif.Request.of_json req with
  | Ok ({ username; _ } as v) when verify v -&gt;
    let token = Jwto.encode HS512 secret [ "username", username ] in
    let token = Result.get_ok token in
    let* () = Vif.Cookie.set ~name:"my-token" server req token in
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let* () = Vif.Response.with_string req "Authenticated!\n" in
    Vif.Response.respond `OK
  | Ok _ -&gt;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let* () = Vif.Response.with_string req "Unauthorized!\n" in
    Vif.Response.respond `Unauthorized
  | Error (`Msg msg) -&gt;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let str = Fmt.str "Invalid JSON: %s\n" msg in
    let* () = Vif.Response.with_string req str in
    Vif.Response.respond (`Code 422)
;;

let routes =
  let open Vif.Uri in
  let open Vif.Route in
  let open Vif.Type in
  [ post (json_encoding credentials) (rel / "login" /?? nil) --&gt; login ]
;;

let () = Miou_unix.run @@ fun () -&gt;
  let env = { secret= "deadbeef" } in
  Vif.run routes env ;;
</code></pre>
<p>As you can see, it is quite simple to load a new library; just use the
<code>require</code> directive. Next, define a new <code>env</code> type that will contain the secret
needed to generate JWTs.</p>
<p>We implement a fairly simple function <code>verify</code> that recognises a single user
with their password.</p>
<p>Finally, we modify the <code>login</code> function to verify the information provided by
the client. If the credentials are correct, we generate a JWT token using our
<code>secret</code> passed to our <code>login</code> function and use <code>Vif.Cookie.set</code> to add a new
cookie.</p>
<p>This is where you can specify the last argument of the <code>Vif.run</code> function. This
value will be passed to all your <em>handlers</em>. Its main purpose is to allow
developers to define their own type containing global information such as the
secret used to generate JWTs. Of course, you can extend the <code>env</code> type. It is
often compared to <code>.env</code> found in several web frameworks.</p>
<p>This is now the result when attempting to log in:</p>
<pre><code class="language-shell">$ hurl -m POST http://localhost:8080/login username=robur password=21 -p rb
HTTP/1.1 401 Unauthorized

Unauthorized!
$ hurl -m POST http://localhost:8080/login username=robur password=42
HTTP/1.1 200 OK

connection: close
content-length: 15
content-type: text/plain; charset=utf-8
set-cookie: __Host-my-token=ALeeJoP8W2KfmX9oYcHMnjeJDuGJmV67brUluoEJgHLZWHEk...
  Path=/; Secure; HttpOnly; SameSite=Lax

Authenticated!
</code></pre>
<p>We are well connected! We can clearly see the cookie that the client should
save. If we take a step back from the code, what we are doing here is managing
a POST request containing identifiers, checking that they are correct, and
creating a JWT using <code>jwto</code> if they are. In this token, we will simply store
the user's <code>username</code>. We then need to inform the client that we would like to
save this token on their end. We do this using <code>Vif.Cookie.set</code> (there are a
whole host of options, but I'll leave you to discover them in the
documentation).</p>
<p>As a client, we can see the cookie (with <code>Set-Cookie</code>). It is encrypted...
twice! Once by Vif itself (you can — and should — specify the encryption key
with Vif.config) and once by <code>jwto</code>.</p>
<p>We can now introduce a new concept in Vif: <em>middleware</em>.</p>
<h2 id="vif-and-middleware"><a class="header" href="#vif-and-middleware">Vif and middleware</a></h2>
<p>Middleware is a simple function that applies to all requests (whether or not
there is a defined route). Within this function, it is possible to inspect the
request, particularly the <em>header</em>. However, it is impossible to:</p>
<ol>
<li>inspect the content of the request</li>
<li>send a response</li>
</ol>
<p>The purpose of middleware is to transform and/or add information from the
header of the incoming request. For example, it is possible to analyse the
cookies sent by the user and determine whether or not they were able to log in.
Finally, this information is added to the request.</p>
<p>After the middleware, the handler associated with the route can finally process
the request to which the middleware has added information. This information can
be retrieved and a response can be sent accordingly.</p>
<p>The goal here would be to have middleware that attempts to deserialise the JWT
present in the cookies. If it succeeds, it means that the person has logged in
previously. The user's <code>username</code> is included in this token, which allows us to
identify them. Here is how to create middleware using Vif.</p>
<pre><code class="language-ocaml">type user =
  { username : string }
;;

let jwt =
  Vif.Middleware.v ~name:"jwt" @@ fun req target server { secret } -&gt;
  match Vif.Cookie.get server req ~name:"my-token" with
  | Error _err -&gt; None
  | Ok token -&gt;
    let ( let* ) = Option.bind in
    let token = Jwto.decode_and_verify secret token in
    let* token = Result.to_option token in
    let* username = List.assoc_opt "username" (Jwto.get_payload token) in
    Some { username }
;;

let index req server _env =
  let open Vif.Response.Syntax in
  match Vif.Request.get jwt req with
  | None -&gt;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let* () = Vif.Response.with_string req "Unauthorized!\n" in
    Vif.Response.respond `Unauthorized
  | Some { username } -&gt;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let str = Fmt.str "Connected as %S!\n" username in
    let* () = Vif.Response.with_string req str in
    Vif.Response.respond `OK
;;

let routes =
  let open Vif.Uri in
  let open Vif.Route in
  let open Vif.Type in
  [ post (json_encoding credentials) (rel / "login" /?? nil) --&gt; login
  ; get (rel /?? nil) --&gt; index ]
;;

let () = Miou_unix.run @@ fun () -&gt;
  let env = { secret= "deadbeef" } in
  let middlewares = Vif.Middlewares.[ jwt ] in
  Vif.run ~middlewares routes env ;;
</code></pre>
<p>Here, we create a new middleware called <code>jwt</code>. Its purpose is to search for a
cookie called <code>my-token</code> (the one we created in the <code>login</code> handler) and decode
(and verify) the JWT. If successful, we should obtain the username of the
current user. We will simply add this information to the current request and
return <code>Some &lt;data&gt;</code>.</p>
<p>In our new <code>index</code> handler, we will try to see if our middleware has returned
the information correctly. If so, it means that the client has a JWT and is
logged in. All we need to do is display the username!</p>
<p>Finally, we need to tell Vif that we want to apply this middleware.</p>
<p>Note that the middleware also has access to our <code>env</code> and therefore also has
access to our <code>secret</code> value (required for <code>jwto</code>). The user can also specify
the type of value that the middleware is capable of creating. In our case, we
have defined the type <code>user</code> containing only the field <code>username</code>. We can of
course extend this type with other values such as the user's ID, age, etc. In
short, Vif allows you to define your own types.</p>
<p>You can now test our website and its user area:</p>
<pre><code class="language-shell">$ curl -X POST http://localhost:8080/login \
  --header 'Content-Type: application/json' \
  --data "{ \"username\": \"robur\", \"password\": \"42\" }" \
  --cookie-jar cookies.txt
Authenticated!
$ curl http://localhost:8080/ --cookie cookies.txt
Connected as "robur"!
$ curl http://localhost:8080/
Unauthorized!
</code></pre>
<p>Et voilà! A user space created using Vif. This allowed us to explore the
concepts of cookies, JWTs, and middleware.</p>
<p>At this stage, we have most of what a framework can offer. We can manage
incoming information (and type it) as specified in our routes or in the request
content, and process this information while allowing developers to specify
their own types.</p>
<p>The main idea is that OCaml, being a typed language, has the advantage of
characterising information (at least, much more than a simple <code>string</code>). We can
use ADTs or records, which are much easier to use. It is then essentially a
matter of defining how to convert untyped information into OCaml values.</p>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next steps</a></h2>
<p>We now have a solid foundation for improving our website. In the next chapter,
we will propose a way to display an HTML page for logging in, which will allow
us to introduce a new format: <code>multipart/form-data</code>. Next, we will see how to
generate HTML dynamically depending on whether the user is logged in or not.
This will allow us to introduce new concepts such as <code>ppx</code> and static files.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-enhanced-userspace"><a class="header" href="#my-enhanced-userspace">My enhanced userspace</a></h1>
<p>We have seen the basic elements for our user space. However, our website is
still quite limited, as it assumes that the user knows how to send a POST
request via the command line. In this chapter, we will improve our user space
so that:</p>
<ul>
<li>we have an HTML page with a login form</li>
<li>we can handle the <code>multipart/form-data</code> format rather than the JSON format</li>
<li>we have a dynamic HTML page depending on whether the user is logged in or not</li>
</ul>
<h2 id="static-html-files-and-conan"><a class="header" href="#static-html-files-and-conan">Static HTML files (and <a href="https://github.com/mirage/conan"><code>conan</code></a>)</a></h2>
<p>When creating a website, we often want to deliver static content such as images
or HTML pages. When sending these documents to the client, important
information is sent along with them: the <a href="https://en.wikipedia.org/wiki/Media_type">MIME type</a>.</p>
<p>This informs the user of the type of content being sent (e.g. whether it is a
<code>*.png</code> or <code>*.jpg</code> image).</p>
<p>With this in mind, we have developed software that can recognise the MIME type
of any file: the <code>conan</code> project. Recognition is not based on the file
extension, but rather on the content and a database that references most MIME
types.</p>
<pre><code class="language-shell">$ conan.file --mime login.html
text/html
</code></pre>
<p>Next, for Vif, we need to add a handler that, depending on the path given by
the request, not only attempts to find the associated static file, but also
recognises its MIME type using <code>conan</code> to deliver it to the client. Let's start
with this HTML form:</p>
<pre><code class="language-xml">&lt;html&gt;
&lt;body&gt;
&lt;form action="/login" method="post" enctype="multipart/form-data"&gt;
  &lt;label for="username"&gt;Enter your username: &lt;/label&gt;
  &lt;input type="text" name="username" required /&gt;
  &lt;label for="password"&gt;Enter your password: &lt;/label&gt;
  &lt;input type="password" name="password" required /&gt;
  &lt;input type="submit" value="Login!" /&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Since the route for delivering a static file depends on the filename, we will
introduce a new concept to Vif: <em>default handlers</em>. When Vif cannot find any
routes for a request, it will execute a series of default handlers until one
produces a response.</p>
<p>For static files, Vif already provides such a handler: <code>Vif.Handler.static</code>.
Just add it to <code>Vif.run</code>:</p>
<pre><code class="language-ocaml">let () = Miou_unix.run @@ fun () -&gt;
  let env = { secret= "deadbeef" } in let middlewares = Vif.Middlewares.[ jwt ]
in let handlers = [ Vif.Handler.static ?top:None ] in Vif.run ~handlers
~middlewares routes env ;;
</code></pre>
<p>The <code>top</code> value corresponds to the location of the static files (so that Vif
prohibits access to other files deeper in the directory tree). In addition, our
<code>login.html</code> file is in the same folder as our <code>main.ml</code> file (however, it is
recommended to create an appropriate folder containing only static files).</p>
<pre><code class="language-shell">$ hurl http://localhost:8080/login.html
HTTP/1.1 200 OK

transfer-encoding: chunked
etag: 3b8eae63b7baa4a7c24bfd8ee7600ee4b97306064e9ea336fca949011058a559
content-length: 356
content-type: text/html

&lt;html&gt;
&lt;body&gt;
&lt;form action="/login" method="post" enctype="multipart/form-data"&gt;
  &lt;label for="username"&gt;Enter your username: &lt;/label&gt;
  &lt;input type="text" name="username" required /&gt;
  &lt;label for="password"&gt;Enter your password: &lt;/label&gt;
  &lt;input type="password" name="password" required /&gt;
  &lt;input type="submit" value="Login!" /&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>We are now able to deliver static files! Note the appearance of <code>ETag</code>. This is
information that allows the client to cache the file (and avoid re-downloading
the content). Finally, note that <code>conan</code> has correctly recognised the MIME type
of our file.</p>
<h3 id="mime-type-and-conan"><a class="header" href="#mime-type-and-conan">MIME-type and <code>conan</code></a></h3>
<p>MIME file recognition is quite difficult and is a topic in itself (in terms of
performance and ability to recognise strange files). Even though <code>conan</code> finds
quite a few solutions, it may happen that we are unable to recognise the file
type. There are other, less obvious ways to transfer the contents of a file
using Vif (such as <code>Vif.Response.with_file</code>), where you can specify the MIME
type manually.</p>
<p>It is also possible to improve <code>conan</code> (and its database) to recognise a subset
or larger set of files. We will leave it up to the user to choose the best
solution for their context.</p>
<h2 id="vif--multipartform-data"><a class="header" href="#vif--multipartform-data">Vif &amp; <code>multipart/form-data</code></a></h2>
<p>In our form, we specify that we would like to transfer the information in
<code>multipart/form-data</code> format. This is a somewhat special format that is often
used for websites. Fortunately, there is an implementation in OCaml that Vif
uses: <a href="https://github.com/dinosaure/multipart_form">multipart_form</a>.</p>
<p>Vif extends this library so that it is as easy to use as <code>jsont</code>: we therefore
offer another DSL for describing the format of your forms:</p>
<pre><code class="language-ocaml">let login_form =
  let open Vif.Multipart_form in
  let fn username password =
    { username; password } in
  record fn
  |+ field "username" string
  |+ field "password" string
  |&gt; sealr
;;

let login req server { secret } =
  let open Vif.Response.Syntax in
  match Vif.Request.of_multipart_form req with
  | Ok ({ username; _ } as v) when login v -&gt;
    let token = Jwto.encode HS512 secret [ "username", username ] in
    let token = Result.get_ok token in
    let str = "Authenticated!\n" in
    let* () = Vif.Cookie.set ~name:"my-token" server req token in
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let* () = Vif.Response.with_string req str in
    Vif.Response.respond `OK
  | Ok _ -&gt;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let* () = Vif.Response.with_string req "Unauthorized!\n" in
    Vif.Response.respond `Unauthorized
  | Error _ -&gt;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let str = Fmt.str "Invalid multipart/form-data\n" in
    let* () = Vif.Response.with_string req str in
    Vif.Response.respond (`Code 422)
;;

let routes =
  let open Vif.Uri in
  let open Vif.Route in
  let open Vif.Type in
  [ post (m login_form) (rel / "login" /?? nil) --&gt; login
  ; get (rel /?? nil) --&gt; index ]
;;
</code></pre>
<p>The idea is almost the same as with <code>jsont</code>. We just need to redefine our login
route with <code>m</code> instead of <code>json_encoding</code> so that Vif accepts requests with a
<code>Content-Type</code> of <code>multipart/form-data</code>.</p>
<pre><code class="language-shell">$ hurl -m POST http://localhost:8080/login --multipart username=robur password=42 -p b
Authenticated!
</code></pre>
<h2 id="vif-tyxml-and-ppx"><a class="header" href="#vif-tyxml-and-ppx">Vif, <code>tyxml</code> and <code>ppx</code></a></h2>
<p>It would now be more useful to transmit HTML content rather than simple text.
Several solutions are available, but we will use one in particular that
emphasises the typed generation of an HTML document using <a href="https://github.com/ocsigen/tyxml">TyXML</a>:</p>
<pre><code class="language-ocaml">#require "tyxml-ppx" ;;
#require "tyxml" ;;

open Tyxml ;;

let%html index username = {html|
&lt;html&gt;
&lt;head&gt;&lt;title&gt;My Vif Website!&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Hello |html} username {html| !&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
|html} ;;

let index username : Tyxml_html.doc = index [ Html.txt username ] ;;

let index req server _env =
  let open Vif.Response.Syntax in
  match Vif.Request.get jwt req with
  | None -&gt;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let* () = Vif.Response.with_string req "Unauthorized!\n" in
    Vif.Response.respond `Unauthorized
  | Some { username } -&gt;
    let* () = Vif.Response.with_tyxml req (index username) in
    Vif.Response.respond `OK
;;
</code></pre>
<p>What's interesting here is that TyXML will check the HTML content to see if it
complies with standards. Furthermore, if you remove the <code>&lt;head&gt;</code> tag, for
example, TyXML will complain that this mandatory tag is missing.</p>
<p>This is not, of course, the only way to deliver content to the client. We can
also respond with JSON as plain text, as we have done since the beginning of
this book. This example essentially shows that it is possible to use <code>ppx</code>
within a Vif script.</p>
<h2 id="vif--redirections"><a class="header" href="#vif--redirections">Vif &amp; redirections</a></h2>
<p>One last small detail, but one that may be important: users should now be
redirected to the main page if they manage to log in, rather than receiving a
message saying that they are logged in. Vif offers a <code>redirect_to</code> function
that allows you to redirect the user to a given <code>Vif.Uri.t</code>.</p>
<pre><code class="language-ocaml">let login req server { secret } =
  let open Vif.Response.Syntax in
  match Vif.Request.of_multipart_form req with
  | Ok ({ username; _ } as v) when login v -&gt;
    let token = Jwto.encode HS512 secret [ "username", username ] in
    let token = Result.get_ok token in
    let str = "Authenticated!\n" in
    let* () = Vif.Cookie.set ~name:"my-token" server req token in
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let* () = Vif.Response.with_string req str in
    Vif.Response.redirect_to req Vif.Uri.(rel /?? any)
  | Ok _ -&gt;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let* () = Vif.Response.with_string req "Unauthorized!\n" in
    Vif.Response.respond `Unauthorized
  | Error _ -&gt;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let str = Fmt.str "Invalid multipart/form-data\n" in
    let* () = Vif.Response.with_string req str in
    Vif.Response.respond (`Code 422)
;;
</code></pre>
<p>We can now test our user space with a single command (since <code>hurl</code> handles
redirection and cookies):</p>
<pre><code class="language-shell">$ curl http://localhost:8080/login -F username=robur -F password=42 -L --cookie-jar cookies.txt
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;head&gt;&lt;title&gt;My Vif Website!&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Hello robur !&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>We're starting to get somewhere. We'll continue using the command line, but we
can now test our website with our web browser! We're producing HTML content,
and all we need to do is log in to <a href="http://localhost:8080/login.html">http://localhost:8080/login.html</a> to
be redirected to our main page!</p>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next steps</a></h2>
<p>At this point, we can consider that the hardest part is done. However, we would
surely like to go further and, in particular, communicate with a database
rather than our simple <code>verify</code> function. In the next chapter, we will see how
to extend our user space so that we can use a persistent database to which our
users can register.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-persistent-userspace"><a class="header" href="#a-persistent-userspace">A persistent userspace</a></h1>
<p>Vif is therefore a web framework, but it does not provide any means of
communicating with a database. However, when developing a website, it is
essential to be able to store information (such as user data) persistently and
independently of our HTTP server. Fortunately, another project allows
communication with a database: <a href="https://github.com/paurkedal/ocaml-caqti">caqti</a>.</p>
<p>In this chapter, we will see how to communicate with a database using <code>caqti</code>
so that our users' information is stored outside the HTTP server and in a
persistent manner. To simplify this chapter, we will use <a href="https://www.sqlite.org/">sqlite3</a>: a
simple file that represents our database (note that <code>caqti</code> can communicate
with other types of databases such as PostGreSQL).</p>
<h2 id="create--use-a-database"><a class="header" href="#create--use-a-database">Create &amp; use a database</a></h2>
<p>Here we will create a simple database with a table called <code>users</code> containing
the user's username and password.</p>
<pre><code class="language-shell">$ sqlite3 vif.db &lt;&lt;EOF
CREATE TABLE users (uid INTEGER, username TEXT, password TEXT, PRIMARY KEY(uid));
.quit
EOF
</code></pre>
<p>Next, we need to modify our Vif script so that we can read this database. To do
this, we will use <code>caqti-miou</code>, the <code>caqti</code> support with our Miou scheduler.</p>
<p>Next, we will need to explain to Vif how to create an instance that can
communicate with our database. Vif uses the concept of <em>devices</em>, which are
<strong>global</strong> instances available from our <code>server</code> instance and therefore
available in all our request handlers.</p>
<p>These <em>devices</em> have the particularity of being <em>domain-safe</em>, meaning that two
domains can request these devices in parallel. We therefore need to ensure that
their manipulation is also <em>domain-safe</em>.</p>
<p>In this case, <code>caqti-miou</code> creates what is called a <em>connection pool</em> to the
database. There is only one database, but several handlers can process SQL
requests in parallel (and require a connection to the database). Thanks to
<code>caqti</code>, we can obtain a <code>CONNECTION</code> to the database (in a <em>domain-safe</em>
manner) and, from this connection, make an SQL query (such as <code>SELECT</code>).</p>
<p>So let's first see how to create a Vif <em>device</em> and how to use it:</p>
<pre><code class="language-ocaml">#require "caqti-miou" ;;
#require "caqti-miou.unix" ;;
#require "caqti-driver-sqlite3" ;;

type env =
  { sw : Caqti_miou.Switch.t
  ; uri : Uri.t
  ; secret : string }
;;

let caqti =
  let finally pool = Caqti_miou_unix.Pool.drain pool in
  Vif.Device.v ~name:"caqti" ~finally [] @@ fun { sw; uri; _ } -&gt;
  match Caqti_miou_unix.connect_pool ~sw uri with
  | Error err -&gt; Fmt.failwith "%a" Caqti_error.pp err
  | Ok pool -&gt; pool
;;

let users req server _ =
  let pool = Vif.Server.device caqti server in
  let sql =
    let open Caqti_request.Infix in
    Caqti_type.(unit -&gt;! int) "SELECT COUNT(uid) FROM users" in
  let fn (module Conn : Caqti_miou.CONNECTION) = Conn.find sql () in
  match Caqti_miou_unix.Pool.use fn pool with
  | Ok n -&gt;
    let open Vif.Response.Syntax in
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset= utf-8" in
    let* () = Vif.Response.with_string req (Fmt.str "%d user(s)!\n" n) in
    Vif.Response.respond `OK
  | Error err -&gt;
    let open Vif.Response.Syntax in
    let str = Fmt.str "SQL error: %a" Caqti_error.pp err in
    let* () = Vif.Response.with_string req str in
    Vif.Response.respond `Internal_server_error
;;

let routes =
  let open Vif.Uri in
  let open Vif.Route in
  let open Vif.Type in
  [ post (m form) (rel / "login" /?? nil) --&gt; login
  ; get (rel /?? nil) --&gt; index
  ; get (rel / "users" /?? nil) --&gt; users ]
;;

let () =
  Miou_unix.run @@ fun () -&gt;
  Caqti_miou.Switch.run @@ fun sw -&gt;
  let uri = Uri.make ~scheme:"sqlite3" ~path:"vif.db" () in
  let env = { sw; uri; secret= "deadbeef" } in
  let middlewares = Vif.Middlewares.[ jwt ] in
  let handlers = [ Vif.Handler.static ?top:None ] in
  let devices = Vif.Devices.[ caqti ] in
  Vif.run ~devices ~handlers ~middlewares routes env
;;
</code></pre>
<p>Here, we extend our <code>env</code> type to include the <code>caqti</code> switch and the <code>uri</code> to
our database. We then create our <code>caqti</code> device, which we will finally pass to
<code>Vif.run</code> (via the <code>devices</code> argument).</p>
<p>The <code>users</code> handler is an example of an SQL query that counts the number of
users. As you can see, we can retrieve our connection pool via
<code>Vif.Server.device caqti</code>. Finally, we need to use this connection pool to make
an SQL query, but we suggest you refer to the <code>caqti</code>
<a href="https://github.com/paurkedal/caqti-study/">documentation</a>.</p>
<pre><code class="language-shell">$ hurl http://localhost:8080/users
HTTP/1.1 200 OK

connection: close
content-length: 11
content-type: text/plain; charset= utf-8

0 user(s)!
</code></pre>
<p>Our database is empty, but this query confirms that we did indeed run an SQL
query to find out that it is empty! The client connected to our Vif server, the
server connected to our database, retrieved the information, processed it, and
then responded in text format that there are zero users.</p>
<h2 id="verify-passwords"><a class="header" href="#verify-passwords">Verify passwords</a></h2>
<p>We will add a new user <em>manually</em> and improve our <code>login</code> function so that it
uses our database:</p>
<pre><code class="language-shell">$ echo -n "42" | sha256sum
73475cb40a568e8da8a045ced110137e159f890ac4da883b6b17dc651b3a8049  -
$ sqlite3 vif.db &lt;&lt;EOF
INSERT INTO users (username, password) VALUES ('robur', '73475cb40a568e8da8a045ced110137e159f890ac4da883b6b17dc651b3a8049');
.quit
EOF
$ hurl http://localhost:8080/users -p b
1 user(s)!
</code></pre>
<p>Here, we can clearly see that the addition of a new user is taken into account
by our Vif server. It should be noted that we do not need to restart our Vif
server to obtain this response. This information is now stored in the database,
and our Vif server will simply (and each time) request the number of users. Now
let's re-implement the <code>login</code> function:</p>
<pre><code class="language-ocaml">#require "digestif.c" ;;
#require "digestif" ;;

type user =
  { uid : int
  ; username : string 
  ; password : Digestif.SHA256.t }
;;

let user =
  let open Caqti_template.Row_type in
  let sha256 =
    let encode hash = Ok (Digestif.SHA256.to_hex hash) in
    let decode hex = Ok (Digestif.SHA256.of_hex hex) in
    custom ~encode ~decode string in
  product (fun uid username password -&gt; { uid; username; password })
  @@ proj int (fun (t : user) -&gt; t.uid)
  @@ proj string (fun (t : user) -&gt; t.username)
  @@ proj sha256 (fun (t : user) -&gt; t.password)
  @@ proj_end
;;

let login server (c : credentials) =
  let pool = Vif.Server.device caqti server in
  let sql =
    let open Caqti_request.Infix in
    Caqti_type.(string -&gt;* user)
      "SELECT * FROM users WHERE username = ?" in
  let fn (module Conn : Caqti_miou.CONNECTION) = Conn.collect_list sql c.username in
  match Caqti_miou_unix.Pool.use fn pool with
  | Ok [ user ] -&gt;
      let h = Digestif.SHA256.digest_string c.password in
      Digestif.SHA256.equal h user.password
  | _ -&gt; false
;;

let login req server { secret } =
  let open Vif.Response.Syntax in
  match Vif.Request.of_multipart_form req with
  | Ok (({ username; _ } : credentials) as c) when login server c -&gt;
    let token = Jwto.encode HS512 secret [ "username", username ] in
    let token = Result.get_ok token in
    let* () = Vif.Cookie.set ~name:"my-token" server req token in
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let* () = Vif.Response.with_string req "Authenticated!\n" in
    Vif.Response.redirect_to req Vif.Uri.(rel /?? any)
  | Ok _ -&gt;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let* () = Vif.Response.with_string req "Unauthorized!\n" in
    Vif.Response.respond `Unauthorized
  | Error _ -&gt;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let str = Fmt.str "Invalid multipart/form-data\n" in
    let* () = Vif.Response.with_string req str in
    Vif.Response.respond (`Code 422)
;;
</code></pre>
<p>We can see that <code>caqti</code> offers (using <code>Caqti_template</code>) more or less the same
DSL that we used with <code>jsont</code> or <code>multipart_form</code>. Using this DSL, we can
describe how to deserialise an SQL value to an OCaml value, which is what we do
with the <code>user</code> type. Next, we modify our first <code>login</code> function so that it
makes the SQL query to search for our user.</p>
<p>Passwords are <em>hashed</em> using the SHA256 algorithm (thanks to the <code>digestif</code>
library). We will therefore hash the value given by the user and compare it
with what we have in the database.</p>
<p>Finally, the second <code>login</code> function changes very little; we just need to
change <code>when verify c</code> to <code>when login server c</code> so that our function can obtain
the <code>caqti</code> connection pool.</p>
<pre><code class="language-shell">$ curl http://localhost:8080/login -F username=robur -F password=42 \
  --cookie-jar cookies.txt -L
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;&lt;title&gt;My Vif Website!&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;&lt;p&gt;Hello robur !&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>We now have a user space that obtains user information from a database!</p>
<p>We would like to emphasise that throughout, we have attempted to type all
information (the password is no longer a string but a hash, which is a type
offered by <a href="https://github.com/mirage/digestif"><code>digestif</code></a>). The results of SQL queries are also typed
using Caqti. The main idea is always to prefer OCaml values (which have
undergone a whole series of checks upstream) to basic values that require a
whole ceremony to validate them (and, above all, to avoid bugs).</p>
<p>We will now focus on creating a new user. However, at this stage, I believe you
should be able to create such a page on your own.</p>
<h2 id="create-a-new-user"><a class="header" href="#create-a-new-user">Create a new user</a></h2>
<p>We will now implement a new page that will be a registration form. This page
will be associated with a POST route that will add the new user to our database
and redirect the client to our index page. We will reuse everything we have
just learned here. Let's start with the registration page <code>registration.html</code>:</p>
<pre><code class="language-xml">&lt;html&gt;
&lt;body&gt;
&lt;form action="/subscribe" method="post" enctype="multipart/form-data"&gt;
  &lt;label for="username"&gt;Enter your username: &lt;/label&gt;
  &lt;input type="text" name="username" required /&gt;
  &lt;label for="password"&gt;Enter your password: &lt;/label&gt;
  &lt;input type="password" name="password" required /&gt;
  &lt;input type="submit" value="Subscribe!" /&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Next, we will create a new POST route to register the user.</p>
<pre><code class="language-ocaml">let subscribe req server _ =
  let pool = Vif.Server.device caqti server in
  let ( let* ) = Result.bind in
  let search =
    let open Caqti_request.Infix in
    Caqti_type.(string -&gt;* user)
      "SELECT * FROM users WHERE username = ?" in
  let insert =
    let open Caqti_request.Infix in
    Caqti_type.(t2 string string -&gt;. unit)
      "INSERT INTO users (username, password) VALUES (?, ?)" in
  let already_exists (c : credentials) (module Conn : Caqti_miou.CONNECTION) =
    let* user = Conn.collect_list search c.username in
    Ok (List.is_empty user == false) in
  let insert (c : credentials) (module Conn : Caqti_miou.CONNECTION) =
    let hash = Digestif.SHA256.digest_string c.password in
    let hash = Digestif.SHA256.to_hex hash in
    Conn.exec insert (c.username, hash) in
  let result =
    let* c = Vif.Request.of_multipart_form req in
    let* () =
      match Caqti_miou_unix.Pool.use (already_exists c) pool with
      | Ok true -&gt; Error (`Already_exists c.username)
      | Ok false -&gt; Ok ()
      | Error (#Caqti_error.t as err) -&gt; Error err in
    match Caqti_miou_unix.Pool.use (insert c) pool with
    | Ok () -&gt; Ok ()
    | Error (#Caqti_error.t as err) -&gt; Error err in
  let open Vif.Response.Syntax in
  match result with
  | Ok () -&gt;
      let* () = Vif.Response.empty in
      Vif.Response.redirect_to req Vif.Uri.(rel / "form.html" /?? any)
  | Error (`Already_exists username) -&gt;
      let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
      let str = Fmt.str "%S already exists.\n" username in
      let* () = Vif.Response.with_string req str in
      Vif.Response.respond `Conflict
  | Error (#Caqti_error.t as err) -&gt;
      let open Vif.Response.Syntax in
      let str = Fmt.str "SQL error: %a" Caqti_error.pp err in
      let* () = Vif.Response.with_string req str in
      Vif.Response.respond `Internal_server_error
  | Error (`Invalid_multipart_form | `Not_found _) -&gt;
      let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
      let str = Fmt.str "Invalid multipart/form-data\n" in
      let* () = Vif.Response.with_string req str in
      Vif.Response.respond (`Code 422)
;;

let routes =
  let open Vif.Uri in
  let open Vif.Route in
  let open Vif.Type in
  [ post (m login_form) (rel / "login" /?? nil) --&gt; login
  ; get (rel /?? nil) --&gt; index
  ; get (rel / "users" /?? nil) --&gt; users
  ; post (m login_form) (rel / "subscribe" /?? nil) --&gt; subscribe ]
;;
</code></pre>
<p>In the code above, we reuse our <code>login_form</code> value, which describes our form.
This is because the form on the <code>register.html</code> page is the same as the one on
<code>login.html</code>.</p>
<p>Next, we check whether the user already exists. We therefore make an initial
SQL query and, if the user does not exist, we make an <code>INSERT</code> query. Finally,
we handle most error cases.</p>
<p>The code may be longer, but what is really interesting is how the <code>result</code>
value is calculated. If we look more closely, this function essentially
consists of SQL queries and returning errors in certain cases. This is where
Vif lets the developer choose how to organise the project.</p>
<p>One solution is to create a library containing the routes, SQL queries and
functions for displaying the results. But all this is outside the scope of Vif,
which is primarily intended to facilitate processes specific to managing HTTP
requests and producing responses.</p>
<p>We can now test our server:</p>
<pre><code class="language-shell">$ hurl -m POST http://localhost:8080/subscribe --multipart username=foo password=bar
HTTP/1.1 303 See Other

location: /form.html
connection: close
content-length: 0
$ curl http://localhost:8080/login -F username=foo -F password=bar -L \
  --cookie-jar cookies.txt
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;&lt;title&gt;My Vif Website!&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;&lt;p&gt;Hello foo !&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Congratulations! You have created the basics of a user space using Vif. At this
point, we recommend that you explore the world of OCaml to see how to develop a
real web application. Vif focuses primarily on the server side, but there are
of course other aspects of web development that Vif does not handle (often
referred to as the front end).</p>
<h2 id="final-steps"><a class="header" href="#final-steps">Final steps</a></h2>
<p>We will conclude this tutorial by creating a <em>chat room</em>. Vif is capable of
managing websockets. This means that several authenticated clients can
communicate with each other in a shared space. This will allow us to explore
more complex but equally interesting features of Vif.</p>
<p>The current site can also be improved in many ways. For example, we can add an
email address (validated by <a href="https://github.com/mirage/emile"><code>emile</code></a>) and send a confirmation email
(using <a href="https://github.com/mirage/colombe"><code>sendmail</code></a>) to complete the registration process.</p>
<p>We could also add an <em>avatar</em> for our users and allow them to upload an image
that would be validated with <code>conan</code> and stored on our server.</p>
<p>In short, there are many possible ways to go at this stage, but the Vif
documentation is quite comprehensive and will provide you with all the
information you need.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-chatroom-with-websockets-and-javascript"><a class="header" href="#a-chatroom-with-websockets-and-javascript">A chatroom with websockets and JavaScript</a></h1>
<p>There is one last way to communicate with our HTTP server: the
<a href="https://en.wikipedia.org/wiki/WebSocket">WebSocket</a> protocol. The advantage of this protocol is that the
connection is full-duplex: throughout the entire process, the user can
communicate with you and you can continuously communicate with them. It's like
a persistent communication.</p>
<p>In short, a good example of the use of WebSockets is a chat room. We want users
to be able to communicate with other users in real time. We will therefore
initiate WebSocket connections between these users in order to <em>multiplex</em> the
messages.</p>
<p>First, we will create a fairly basic page where users can send messages to each
other:</p>
<pre><code class="language-xml">&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;script type="text/javascript" defer="defer" src="chat.js"&gt;&lt;/script&gt;
  &lt;title&gt;Chat room&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;form id="send"&gt;
    &lt;input type="text" name="msg" required /&gt;
    &lt;input type="submit" value="Send!" /&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Here we add a file called <code>chat.js</code>, which will be the result of compiling an
OCaml file using <code>js_of_ocaml</code>. This small JavaScript script has two objectives:</p>
<ol>
<li>connect to the server via WebSocket and receive messages to write on the page</li>
<li>send messages as soon as the user clicks on the <code>Send!</code> button.</li>
</ol>
<p>To implement all this, we will use <a href="https://github.com/dbuenzli/brr"><code>brr</code></a>, a library that interfaces
JavaScript functions in OCaml:</p>
<pre><code class="language-ocaml">let form_elem = Brr.El.find_first_by_selector (Jstr.v "#send") |&gt; Option.get

let send_message ev_submit =
  let open Fut.Syntax in
  let _ = Jv.call (Brr.Ev.to_jv ev_submit) "preventDefault" [||] in
  let form_elem = Brr_io.Form.of_el form_elem in
  let form_data = Brr_io.Form.Data.of_form form_elem in
  let body = Brr_io.Fetch.Body.of_form_data form_data
  and credentials = Brr_io.Fetch.Request.Credentials.same_origin in
  let init = Brr_io.Fetch.Request.init
    ~body ~credentials ~method':(Jstr.v "POST") () in
  let req = Brr_io.Fetch.Request.v ~init (Jstr.v "http://localhost:8080/send") in
  Fut.await begin
    let* result = Brr_io.Fetch.request req in
    match result with
    | Ok resp when Brr_io.Fetch.Response.ok resp -&gt; Fut.return ()
    | Ok resp -&gt; print_endline "Error!"; Fut.return ()
    | Error _ -&gt; print_endline "Error!"; Fut.return ()
  end @@ Fun.id

let on_message ev =
  let msg = Jv.Jstr.get (Brr.Ev.to_jv ev) "data" in
  let div = Brr.El.(div [txt msg]) in
  Brr.El.append_children (Brr.Document.body Brr.G.document) [div]

let () =
  let socket = Brr_io.Websocket.create (Jstr.v "http://localhost:8080/chat") in
  let target = Brr_io.Websocket.as_target socket in
  let event = Brr.Ev.Type.create (Jstr.v "message") in
  ignore (Brr.Ev.listen event on_message target);
  let target = Brr.El.as_target form_elem in
  ignore (Brr.Ev.listen Brr_io.Form.Ev.submit send_message target)
</code></pre>
<p>The code may seem complex, and we could write the equivalent in JavaScript, but
let's stay in the world of OCaml. The goal here is to retrieve our form and be
able to read what the user has written as soon as they press the "Send!"
button.</p>
<p>Next, we initiate a WebSocket connection with our server (taking care to keep
our cookies so that we can remain authenticated).</p>
<p>Finally, for each message received from the WebSocket, we will simply write it
<em>on the fly</em> on the page.</p>
<p>The JavaScript code can be obtained in this way:</p>
<pre><code class="language-shell">$ opam install brr js_of_ocaml
$ ocamlfind c -linkpkg -package brr chat.ml
$ js_of_ocaml a.out -o chat.js
</code></pre>
<p>That's all we need on the client side. We will now return to Vif to:</p>
<ol>
<li>propose a <em>handler</em> to the WebSocket protocol</li>
<li>and create a new POST route to send messages</li>
</ol>
<h2 id="our-listeners-on-our-vif-server"><a class="header" href="#our-listeners-on-our-vif-server">Our listeners on our Vif server</a></h2>
<p>The idea behind our chatroom is quite simple. When someone connects to our
server via websocket, we create a <em>listener</em> in the sense that the client will
listen for any new messages.</p>
<p>This listener will be stored in a global value so that it can be retrieved from
any request handlers. As such, access must be protected so that this global
value is <em>domain-safe</em>.</p>
<p>There are three essential operations:</p>
<ol>
<li>create a listener</li>
<li>send a message to all listeners (i.e. all connected clients)</li>
<li>delete a listener</li>
</ol>
<pre><code class="language-ocaml">type chatroom =
  { make : unit -&gt; int * string Vif.Stream.source
  ; send : string -&gt; unit
  ; shutdown : int -&gt; unit }
;;

let chatroom =
  let uid = Atomic.make 0 in
  let actives = Hashtbl.create 0x100 in
  let mutex = Miou.Mutex.create () in
  let make () =
    let n = Atomic.fetch_and_add uid 1 in
    Miou.Mutex.protect mutex @@ fun () -&gt;
    let q = Vif.Stream.Bqueue.create 0x100 in
    Hashtbl.replace actives n q;
    n, Vif.Stream.Source.of_bqueue q in
  let shutdown uid =
    Miou.Mutex.protect mutex @@ fun () -&gt;
    Hashtbl.remove actives uid in
  let send msg =
    Miou.Mutex.protect mutex @@ fun () -&gt;
    let fn _ q = Vif.Stream.Bqueue.put q msg in
    Hashtbl.iter fn actives in
  let finally _ =
    Miou.Mutex.protect mutex @@ fun () -&gt;
    let fn _ q = Vif.Stream.Bqueue.close q in
    Hashtbl.iter fn actives in
  Vif.Device.v ~name:"chatroom" ~finally [] @@ fun _ -&gt;
  { make; send; shutdown }
;;
</code></pre>
<p>Here, we introduce two new concepts: a bounded queue and streams. We won't go
into detail about these modules, but they allow information to be transmitted
(and it's always <em>domain-safe</em>) between tasks. Conceptually, several tasks
(probably dispatched across several domains) will run to <em>listen</em> for any
messages we might want to send. A task will then appear that will execute the
handler for the POST request (allowing messages to be sent) and will have to
transmit this message to all active listeners (this is the purpose of the
<code>send</code> function).</p>
<p>Our chatroom, being global to our server, will be a device. We will then create
the WebSocket handler and a final route to be able to send messages.</p>
<h2 id="websocket"><a class="header" href="#websocket">Websocket</a></h2>
<p>The WebSocket protocol is a protocol that can be initiated from an HTTP
request. It involves creating a route and informing the client that we would
like to switch to the WebSocket protocol rather than HTTP, which is called an
<em>upgrade</em>. Vif allows you to attempt this upgrade. The client will then be
redirected to another handler, the WebSocket handler. This handler is special
because it no longer processes a request and provides a response, but works
with a stream of inputs (<code>ic</code>) and a stream of outputs (<code>oc</code>).</p>
<pre><code class="language-ocaml">let chat req server _ = Vif.Response.websocket ;;

let websocket ic oc server _ =
  let t = Vif.Server.device chatroom server in
  let uid, src = t.make () in
  let fn str = oc (`Msg (`Text, true), str) in
  let prm0 = Miou.async @@ fun () -&gt; Vif.Stream.Source.each fn src in
  let prm1 = Miou.async @@ fun () -&gt;
    let rec go () =
      match ic () with
      | None | Some (`Connection_close, _) -&gt; oc (`Connection_close, String.empty)
      | Some _ -&gt; go () in
    go () in
  let _ = Miou.await_first [ prm0; prm1 ] in
  t.shutdown uid
;;
</code></pre>
<p>Here, we introduce a few concepts related to Miou. When a client connects to
our websocket, the goal is to create tasks that will work together:</p>
<ol>
<li>one will consume everything the client can send (and it should not send
anything normally)</li>
<li>the other task will consist of transmitting messages from our <em>listener</em> to
our client</li>
</ol>
<p><code>Vif.Stream.Source.each</code> will execute <code>fn</code> as soon as the listener receives a
message, and <code>fn</code> will simply write this message to the client using <code>oc</code>.</p>
<p>One or both of these tasks will stop (because the client has disconnected or
because we want to shutdown the server). What is certain is that in any case,
everything must end. <code>Miou.await_first</code> will wait for one of the tasks and,
more importantly, will <em>cancel</em> the other. We can finally release the listener
resource correctly.</p>
<p>It may be interesting to look at Miou at this point and how it manages tasks.
We can recommend <a href="https://robur-coop.github.io/miou/">a short book</a> that explains in detail what a
scheduler looks like in OCaml 5 (with effects) and what Miou offers.</p>
<h2 id="send-a-message"><a class="header" href="#send-a-message">Send a message!</a></h2>
<p>Here, we will create a new handler, which will be our last one and will
summarise everything we have learned since the beginning of this short book. It
is a handler for a POST request in which we would have our message (<code>msg</code>). It
is still a question of whether the client is connected, and we will simply
prefix the message with the client's name.</p>
<pre><code class="language-ocaml">type msg = { msg : string } ;;

let msg =
  let open Vif.Multipart_form in
  let fn msg = { msg } in
  record fn
  |+ field "msg" string
  |&gt; sealr
;;

let send req server _ =
  let open Vif.Response.Syntax in
  match Vif.Request.of_multipart_form req, Vif.Request.get jwt req with
  | Ok { msg }, Some { username }-&gt;
    let t = Vif.Server.device chatroom server in
    let str = Fmt.str "%s: %s\n" username msg in
    t.send str;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let* () = Vif.Response.with_string req "Message sent!\n" in
    Vif.Response.respond `OK
  | Error _, _ -&gt;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let str = Fmt.str "Invalid multipart/form-data\n" in
    let* () = Vif.Response.with_string req str in
    Vif.Response.respond (`Code 422)
  | _, None -&gt;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let* () = Vif.Response.with_string req "Unauthorized!" in
    Vif.Response.respond `Unauthorized
;;
</code></pre>
<p>Note that we are reusing our <code>chatroom</code> device here. This does not involve
creating a listener as in our WebSocket handler, but rather <em>broadcasting</em> the
message to all listeners.</p>
<h2 id="mix-them-all"><a class="header" href="#mix-them-all">Mix them all!</a></h2>
<p>We now need to properly configure our new <code>chatroom</code> device in Vif and give it
the handler for WebSocket connections:</p>
<pre><code class="language-ocaml">let routes =
  let open Vif.Uri in
  let open Vif.Route in
  let open Vif.Type in
  [ post (m login_form) (rel / "login" /?? nil) --&gt; login
  ; get (rel /?? nil) --&gt; index
  ; get (rel / "users" /?? nil) --&gt; users
  ; post (m login_form) (rel / "subscribe" /?? nil) --&gt; subscribe
  ; get (rel / "chat" /?? nil) --&gt; chat
  ; post (m msg) (rel / "send" /?? nil) --&gt; send ]
;;

let () =
  Miou_unix.run @@ fun () -&gt;
  Caqti_miou.Switch.run @@ fun sw -&gt;
  let uri = Uri.make ~scheme:"sqlite3" ~path:"vif.db" () in
  let env = { sw; uri; secret= "deadbeef" } in
  let middlewares = Vif.Middlewares.[ jwt ] in
  let handlers = [ Vif.Handler.static ?top:None ] in
  let devices = Vif.Devices.[ caqti; chatroom ] in
  Vif.run ~devices ~handlers ~middlewares ~websocket routes env
;;
</code></pre>
<p>There you go! You can now access the page <a href="http://localhost:8080/chat.html">http://localhost:8080/chat.html</a>
and, if you are logged in, you can send a message that others will be able to
read. It's a real chat room made with Vif.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Of course, there is room for improvement (starting with the design!). But the
bulk of the logic, the backend, is there. Despite Vif's minimalism, it is
possible to achieve satisfactory results fairly quickly.</p>
<p>Vif offers a way to develop websites with OCaml by taking up the idea of OCaml
scripts. Fortunately, this is not the central idea (note the use of effects
with Miou, the possibility of parallelising request management with OCaml 5,
etc.). The idea of scripting in OCaml is interesting because it requires very
little to get a website up and running.</p>
<p>Finally, Vif attempts to offer, at all levels of the HTTP protocol, a way of
typing information so that all checks can be performed upstream using DSLs such
as <code>jsont</code> or <code>caqti</code>. The idea is to really take advantage of the OCaml type
system (and see it more as an assistant rather than a constraint).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memento"><a class="header" href="#memento">Memento</a></h1>
<p>Vif is a project run by our cooperative, which can result in saturation of the
"HTTP stack in OCaml". It is true that, at the time of writing, there are
several solutions for creating a website in OCaml. So why Vif, and how is it
better?</p>
<h2 id="competition-and-space"><a class="header" href="#competition-and-space">Competition and space</a></h2>
<p>In reality, Vif synthesises a social reality which, without its existence,
would leave little room for our cooperative to continue producing services and
unikernels.</p>
<p>As such, it is important to understand where we are coming from. Our
cooperative is (or has been) involved in the development of the various HTTP
stacks currently available in OCaml. In this case, we continue to do
(painstaking) maintenance work on some of these libraries.</p>
<p>This work is not new and stems from our experience working on
[Ocsigen][ocsigen], [CoHTTP][cohttp], [http/af][httpaf], [h2][h2] and
[Dream][dream]. Of course, all of this is transparent and can be seen in our
issues and pull requests on these various projects. We have therefore been
collaborating on these projects for around ten years.</p>
<p>However, we feel that this collaboration has not always been fruitful, and we
have noticed certain limitations between the objectives of the authors of these
HTTP stacks and our own. This is not a criticism, but rather an observation
that has led us to reconsider the use of these solutions several times in light
of our constraints and objectives.</p>
<p>Vif does not seek to compete with anyone and responds to a specific need of our
cooperative, which does not have the ability to improve what already exists in
the way we would like (this certainly does not mean that we would
systematically want to change these projects, but we could also reasonably
conclude that they did not suit our constraints), but we do have experience in
producing such a stack thanks to our regular work.</p>
<p>And since we accept the diversity of solutions by continuing to participate in
and maintain these pre-existing HTTP stacks, we would like readers to
legitimise the existence of Vif as another possible HTTP stack for building
websites.</p>
<h2 id="experiences--objectives"><a class="header" href="#experiences--objectives">Experiences &amp; objectives</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
