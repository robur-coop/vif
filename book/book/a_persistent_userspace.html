<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A persistent userspace - Vif, a simple webserver in OCaml</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Vif, a simple webserver in OCaml</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="a-persistent-userspace"><a class="header" href="#a-persistent-userspace">A persistent userspace</a></h1>
<p>Vif is therefore a web framework, but it does not provide any means of
communicating with a database. However, when developing a website, it is
essential to be able to store information (such as user data) persistently and
independently of our HTTP server. Fortunately, another project allows
communication with a database: <a href="https://github.com/paurkedal/ocaml-caqti">caqti</a>.</p>
<p>In this chapter, we will see how to communicate with a database using <code>caqti</code>
so that our users' information is stored outside the HTTP server and in a
persistent manner. To simplify this chapter, we will use <a href="https://www.sqlite.org/">sqlite3</a>: a
simple file that represents our database (note that <code>caqti</code> can communicate
with other types of databases such as PostGreSQL).</p>
<h2 id="create--use-a-database"><a class="header" href="#create--use-a-database">Create &amp; use a database</a></h2>
<p>Here we will create a simple database with a table called <code>users</code> containing
the user's username and password.</p>
<pre><code class="language-shell">$ sqlite3 vif.db &lt;&lt;EOF
CREATE TABLE users (uid INTEGER, username TEXT, password TEXT, PRIMARY KEY(uid));
.quit
EOF
</code></pre>
<p>Next, we need to modify our Vif script so that we can read this database. To do
this, we will use <code>caqti-miou</code>, the <code>caqti</code> support with our Miou scheduler.</p>
<p>Next, we will need to explain to Vif how to create an instance that can
communicate with our database. Vif uses the concept of <em>devices</em>, which are
<strong>global</strong> instances available from our <code>server</code> instance and therefore
available in all our request handlers.</p>
<p>These <em>devices</em> have the particularity of being <em>domain-safe</em>, meaning that two
domains can request these devices in parallel. We therefore need to ensure that
their manipulation is also <em>domain-safe</em>.</p>
<p>In this case, <code>caqti-miou</code> creates what is called a <em>connection pool</em> to the
database. There is only one database, but several handlers can process SQL
requests in parallel (and require a connection to the database). Thanks to
<code>caqti</code>, we can obtain a <code>CONNECTION</code> to the database (in a <em>domain-safe</em>
manner) and, from this connection, make an SQL query (such as <code>SELECT</code>).</p>
<p>So let's first see how to create a Vif <em>device</em> and how to use it:</p>
<pre><code class="language-ocaml">#require "caqti-miou" ;;
#require "caqti-miou.unix" ;;
#require "caqti-driver-sqlite3" ;;

type env =
  { sw : Caqti_miou.Switch.t
  ; uri : Uri.t
  ; secret : string }
;;

let caqti =
  let finally pool = Caqti_miou_unix.Pool.drain pool in
  Vif.Device.v ~name:"caqti" ~finally [] @@ fun { sw; uri; _ } -&gt;
  match Caqti_miou_unix.connect_pool ~sw uri with
  | Error err -&gt; Fmt.failwith "%a" Caqti_error.pp err
  | Ok pool -&gt; pool
;;

let users req server _ =
  let pool = Vif.Server.device caqti server in
  let sql =
    let open Caqti_request.Infix in
    Caqti_type.(unit -&gt;! int) "SELECT COUNT(uid) FROM users" in
  let fn (module Conn : Caqti_miou.CONNECTION) = Conn.find sql () in
  match Caqti_miou_unix.Pool.use fn pool with
  | Ok n -&gt;
    let open Vif.Response.Syntax in
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset= utf-8" in
    let* () = Vif.Response.with_string req (Fmt.str "%d user(s)!\n" n) in
    Vif.Response.respond `OK
  | Error err -&gt;
    let open Vif.Response.Syntax in
    let str = Fmt.str "SQL error: %a" Caqti_error.pp err in
    let* () = Vif.Response.with_string req str in
    Vif.Response.respond `Internal_server_error
;;

let routes =
  let open Vif.Uri in
  let open Vif.Route in
  let open Vif.Type in
  [ post (m form) (rel / "login" /?? nil) --&gt; login
  ; get (rel /?? nil) --&gt; index
  ; get (rel / "users" /?? nil) --&gt; users ]
;;

let () =
  Miou_unix.run @@ fun () -&gt;
  Caqti_miou.Switch.run @@ fun sw -&gt;
  let uri = Uri.make ~scheme:"sqlite3" ~path:"vif.db" () in
  let env = { sw; uri; secret= "deadbeef" } in
  let middlewares = Vif.Middlewares.[ jwt ] in
  let handlers = [ Vif.Handler.static ?top:None ] in
  let devices = Vif.Devices.[ caqti ] in
  Vif.run ~devices ~handlers ~middlewares routes env
;;
</code></pre>
<p>Here, we extend our <code>env</code> type to include the <code>caqti</code> switch and the <code>uri</code> to
our database. We then create our <code>caqti</code> device, which we will finally pass to
<code>Vif.run</code> (via the <code>devices</code> argument).</p>
<p>The <code>users</code> handler is an example of an SQL query that counts the number of
users. As you can see, we can retrieve our connection pool via
<code>Vif.Server.device caqti</code>. Finally, we need to use this connection pool to make
an SQL query, but we suggest you refer to the <code>caqti</code>
<a href="https://github.com/paurkedal/caqti-study/">documentation</a>.</p>
<pre><code class="language-shell">$ hurl http://localhost:8080/users
HTTP/1.1 200 OK

connection: close
content-length: 11
content-type: text/plain; charset= utf-8

0 user(s)!
</code></pre>
<p>Our database is empty, but this query confirms that we did indeed run an SQL
query to find out that it is empty! The client connected to our Vif server, the
server connected to our database, retrieved the information, processed it, and
then responded in text format that there are zero users.</p>
<h2 id="verify-passwords"><a class="header" href="#verify-passwords">Verify passwords</a></h2>
<p>We will add a new user <em>manually</em> and improve our <code>login</code> function so that it
uses our database:</p>
<pre><code class="language-shell">$ echo -n "42" | sha256sum
73475cb40a568e8da8a045ced110137e159f890ac4da883b6b17dc651b3a8049  -
$ sqlite3 vif.db &lt;&lt;EOF
INSERT INTO users (username, password) VALUES ('robur', '73475cb40a568e8da8a045ced110137e159f890ac4da883b6b17dc651b3a8049');
.quit
EOF
$ hurl http://localhost:8080/users -p b
1 user(s)!
</code></pre>
<p>Here, we can clearly see that the addition of a new user is taken into account
by our Vif server. It should be noted that we do not need to restart our Vif
server to obtain this response. This information is now stored in the database,
and our Vif server will simply (and each time) request the number of users. Now
let's re-implement the <code>login</code> function:</p>
<pre><code class="language-ocaml">#require "digestif.c" ;;
#require "digestif" ;;

type user =
  { uid : int
  ; username : string 
  ; password : Digestif.SHA256.t }
;;

let user =
  let open Caqti_template.Row_type in
  let sha256 =
    let encode hash = Ok (Digestif.SHA256.to_hex hash) in
    let decode hex = Ok (Digestif.SHA256.of_hex hex) in
    custom ~encode ~decode string in
  product (fun uid username password -&gt; { uid; username; password })
  @@ proj int (fun (t : user) -&gt; t.uid)
  @@ proj string (fun (t : user) -&gt; t.username)
  @@ proj sha256 (fun (t : user) -&gt; t.password)
  @@ proj_end
;;

let login server (c : credentials) =
  let pool = Vif.Server.device caqti server in
  let sql =
    let open Caqti_request.Infix in
    Caqti_type.(string -&gt;* user)
      "SELECT * FROM users WHERE username = ?" in
  let fn (module Conn : Caqti_miou.CONNECTION) = Conn.collect_list sql c.username in
  match Caqti_miou_unix.Pool.use fn pool with
  | Ok [ user ] -&gt;
      let h = Digestif.SHA256.digest_string c.password in
      Digestif.SHA256.equal h user.password
  | _ -&gt; false
;;

let login req server { secret } =
  let open Vif.Response.Syntax in
  match Vif.Request.of_multipart_form req with
  | Ok (({ username; _ } : credentials) as c) when login server c -&gt;
    let token = Jwto.encode HS512 secret [ "username", username ] in
    let token = Result.get_ok token in
    let* () = Vif.Cookie.set ~name:"my-token" server req token in
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let* () = Vif.Response.with_string req "Authenticated!\n" in
    Vif.Response.redirect_to req Vif.Uri.(rel /?? any)
  | Ok _ -&gt;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let* () = Vif.Response.with_string req "Unauthorized!\n" in
    Vif.Response.respond `Unauthorized
  | Error _ -&gt;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let str = Fmt.str "Invalid multipart/form-data\n" in
    let* () = Vif.Response.with_string req str in
    Vif.Response.respond (`Code 422)
;;
</code></pre>
<p>We can see that <code>caqti</code> offers (using <code>Caqti_template</code>) more or less the same
DSL that we used with <code>jsont</code> or <code>multipart_form</code>. Using this DSL, we can
describe how to deserialise an SQL value to an OCaml value, which is what we do
with the <code>user</code> type. Next, we modify our first <code>login</code> function so that it
makes the SQL query to search for our user.</p>
<p>Passwords are <em>hashed</em> using the SHA256 algorithm (thanks to the <code>digestif</code>
library). We will therefore hash the value given by the user and compare it
with what we have in the database.</p>
<p>Finally, the second <code>login</code> function changes very little; we just need to
change <code>when verify c</code> to <code>when login server c</code> so that our function can obtain
the <code>caqti</code> connection pool.</p>
<pre><code class="language-shell">$ curl http://localhost:8080/login -F username=robur -F password=42 \
  --cookie-jar cookies.txt -L
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;&lt;title&gt;My Vif Website!&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;&lt;p&gt;Hello robur !&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>We now have a user space that obtains user information from a database!</p>
<p>We would like to emphasise that throughout, we have attempted to type all
information (the password is no longer a string but a hash, which is a type
offered by <a href="https://github.com/mirage/digestif"><code>digestif</code></a>). The results of SQL queries are also typed
using Caqti. The main idea is always to prefer OCaml values (which have
undergone a whole series of checks upstream) to basic values that require a
whole ceremony to validate them (and, above all, to avoid bugs).</p>
<p>We will now focus on creating a new user. However, at this stage, I believe you
should be able to create such a page on your own.</p>
<h2 id="create-a-new-user"><a class="header" href="#create-a-new-user">Create a new user</a></h2>
<p>We will now implement a new page that will be a registration form. This page
will be associated with a POST route that will add the new user to our database
and redirect the client to our index page. We will reuse everything we have
just learned here. Let's start with the registration page <code>registration.html</code>:</p>
<pre><code class="language-xml">&lt;html&gt;
&lt;body&gt;
&lt;form action="/subscribe" method="post" enctype="multipart/form-data"&gt;
  &lt;label for="username"&gt;Enter your username: &lt;/label&gt;
  &lt;input type="text" name="username" required /&gt;
  &lt;label for="password"&gt;Enter your password: &lt;/label&gt;
  &lt;input type="password" name="password" required /&gt;
  &lt;input type="submit" value="Subscribe!" /&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Next, we will create a new POST route to register the user.</p>
<pre><code class="language-ocaml">let subscribe req server _ =
  let pool = Vif.Server.device caqti server in
  let ( let* ) = Result.bind in
  let search =
    let open Caqti_request.Infix in
    Caqti_type.(string -&gt;* user)
      "SELECT * FROM users WHERE username = ?" in
  let insert =
    let open Caqti_request.Infix in
    Caqti_type.(t2 string string -&gt;. unit)
      "INSERT INTO users (username, password) VALUES (?, ?)" in
  let already_exists (c : credentials) (module Conn : Caqti_miou.CONNECTION) =
    let* user = Conn.collect_list search c.username in
    Ok (List.is_empty user == false) in
  let insert (c : credentials) (module Conn : Caqti_miou.CONNECTION) =
    let hash = Digestif.SHA256.digest_string c.password in
    let hash = Digestif.SHA256.to_hex hash in
    Conn.exec insert (c.username, hash) in
  let result =
    let* c = Vif.Request.of_multipart_form req in
    let* () =
      match Caqti_miou_unix.Pool.use (already_exists c) pool with
      | Ok true -&gt; Error (`Already_exists c.username)
      | Ok false -&gt; Ok ()
      | Error (#Caqti_error.t as err) -&gt; Error err in
    match Caqti_miou_unix.Pool.use (insert c) pool with
    | Ok () -&gt; Ok ()
    | Error (#Caqti_error.t as err) -&gt; Error err in
  let open Vif.Response.Syntax in
  match result with
  | Ok () -&gt;
      let* () = Vif.Response.empty in
      Vif.Response.redirect_to req Vif.Uri.(rel / "form.html" /?? any)
  | Error (`Already_exists username) -&gt;
      let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
      let str = Fmt.str "%S already exists.\n" username in
      let* () = Vif.Response.with_string req str in
      Vif.Response.respond `Conflict
  | Error (#Caqti_error.t as err) -&gt;
      let open Vif.Response.Syntax in
      let str = Fmt.str "SQL error: %a" Caqti_error.pp err in
      let* () = Vif.Response.with_string req str in
      Vif.Response.respond `Internal_server_error
  | Error (`Invalid_multipart_form | `Not_found _) -&gt;
      let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
      let str = Fmt.str "Invalid multipart/form-data\n" in
      let* () = Vif.Response.with_string req str in
      Vif.Response.respond (`Code 422)
;;

let routes =
  let open Vif.Uri in
  let open Vif.Route in
  let open Vif.Type in
  [ post (m login_form) (rel / "login" /?? nil) --&gt; login
  ; get (rel /?? nil) --&gt; index
  ; get (rel / "users" /?? nil) --&gt; users
  ; post (m login_form) (rel / "subscribe" /?? nil) --&gt; subscribe ]
;;
</code></pre>
<p>In the code above, we reuse our <code>login_form</code> value, which describes our form.
This is because the form on the <code>register.html</code> page is the same as the one on
<code>login.html</code>.</p>
<p>Next, we check whether the user already exists. We therefore make an initial
SQL query and, if the user does not exist, we make an <code>INSERT</code> query. Finally,
we handle most error cases.</p>
<p>The code may be longer, but what is really interesting is how the <code>result</code>
value is calculated. If we look more closely, this function essentially
consists of SQL queries and returning errors in certain cases. This is where
Vif lets the developer choose how to organise the project.</p>
<p>One solution is to create a library containing the routes, SQL queries and
functions for displaying the results. But all this is outside the scope of Vif,
which is primarily intended to facilitate processes specific to managing HTTP
requests and producing responses.</p>
<p>We can now test our server:</p>
<pre><code class="language-shell">$ hurl -m POST http://localhost:8080/subscribe --multipart username=foo password=bar
HTTP/1.1 303 See Other

location: /form.html
connection: close
content-length: 0
$ curl http://localhost:8080/login -F username=foo -F password=bar -L \
  --cookie-jar cookies.txt
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;&lt;title&gt;My Vif Website!&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;&lt;p&gt;Hello foo !&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Congratulations! You have created the basics of a user space using Vif. At this
point, we recommend that you explore the world of OCaml to see how to develop a
real web application. Vif focuses primarily on the server side, but there are
of course other aspects of web development that Vif does not handle (often
referred to as the front end).</p>
<h2 id="final-steps"><a class="header" href="#final-steps">Final steps</a></h2>
<p>We will conclude this tutorial by creating a <em>chat room</em>. Vif is capable of
managing websockets. This means that several authenticated clients can
communicate with each other in a shared space. This will allow us to explore
more complex but equally interesting features of Vif.</p>
<p>The current site can also be improved in many ways. For example, we can add an
email address (validated by <a href="https://github.com/mirage/emile"><code>emile</code></a>) and send a confirmation email
(using <a href="https://github.com/mirage/colombe"><code>sendmail</code></a>) to complete the registration process.</p>
<p>We could also add an <em>avatar</em> for our users and allow them to upload an image
that would be validated with <code>conan</code> and stored on our server.</p>
<p>In short, there are many possible ways to go at this stage, but the Vif
documentation is quite comprehensive and will provide you with all the
information you need.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="my_enhanced_userspace.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="a_chatroom.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="my_enhanced_userspace.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="a_chatroom.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
