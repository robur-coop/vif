<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A chatroom - Vif, a simple webserver in OCaml</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Vif, a simple webserver in OCaml</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="a-chatroom-with-websockets-and-javascript"><a class="header" href="#a-chatroom-with-websockets-and-javascript">A chatroom with websockets and JavaScript</a></h1>
<p>There is one last way to communicate with our HTTP server: the
<a href="https://en.wikipedia.org/wiki/WebSocket">WebSocket</a> protocol. The advantage of this protocol is that the
connection is full-duplex: throughout the entire process, the user can
communicate with you and you can continuously communicate with them. It's like
a persistent communication.</p>
<p>In short, a good example of the use of WebSockets is a chat room. We want users
to be able to communicate with other users in real time. We will therefore
initiate WebSocket connections between these users in order to <em>multiplex</em> the
messages.</p>
<p>First, we will create a fairly basic page where users can send messages to each
other:</p>
<pre><code class="language-xml">&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;script type="text/javascript" defer="defer" src="chat.js"&gt;&lt;/script&gt;
  &lt;title&gt;Chat room&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;form id="send"&gt;
    &lt;input type="text" name="msg" required /&gt;
    &lt;input type="submit" value="Send!" /&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Here we add a file called <code>chat.js</code>, which will be the result of compiling an
OCaml file using <code>js_of_ocaml</code>. This small JavaScript script has two objectives:</p>
<ol>
<li>connect to the server via WebSocket and receive messages to write on the page</li>
<li>send messages as soon as the user clicks on the <code>Send!</code> button.</li>
</ol>
<p>To implement all this, we will use <a href="https://github.com/dbuenzli/brr"><code>brr</code></a>, a library that interfaces
JavaScript functions in OCaml:</p>
<pre><code class="language-ocaml">let form_elem = Brr.El.find_first_by_selector (Jstr.v "#send") |&gt; Option.get

let send_message ev_submit =
  let open Fut.Syntax in
  let _ = Jv.call (Brr.Ev.to_jv ev_submit) "preventDefault" [||] in
  let form_elem = Brr_io.Form.of_el form_elem in
  let form_data = Brr_io.Form.Data.of_form form_elem in
  let body = Brr_io.Fetch.Body.of_form_data form_data
  and credentials = Brr_io.Fetch.Request.Credentials.same_origin in
  let init = Brr_io.Fetch.Request.init
    ~body ~credentials ~method':(Jstr.v "POST") () in
  let req = Brr_io.Fetch.Request.v ~init (Jstr.v "http://localhost:8080/send") in
  Fut.await begin
    let* result = Brr_io.Fetch.request req in
    match result with
    | Ok resp when Brr_io.Fetch.Response.ok resp -&gt; Fut.return ()
    | Ok resp -&gt; print_endline "Error!"; Fut.return ()
    | Error _ -&gt; print_endline "Error!"; Fut.return ()
  end @@ Fun.id

let on_message ev =
  let msg = Jv.Jstr.get (Brr.Ev.to_jv ev) "data" in
  let div = Brr.El.(div [txt msg]) in
  Brr.El.append_children (Brr.Document.body Brr.G.document) [div]

let () =
  let socket = Brr_io.Websocket.create (Jstr.v "http://localhost:8080/chat") in
  let target = Brr_io.Websocket.as_target socket in
  let event = Brr.Ev.Type.create (Jstr.v "message") in
  ignore (Brr.Ev.listen event on_message target);
  let target = Brr.El.as_target form_elem in
  ignore (Brr.Ev.listen Brr_io.Form.Ev.submit send_message target)
</code></pre>
<p>The code may seem complex, and we could write the equivalent in JavaScript, but
let's stay in the world of OCaml. The goal here is to retrieve our form and be
able to read what the user has written as soon as they press the "Send!"
button.</p>
<p>Next, we initiate a WebSocket connection with our server (taking care to keep
our cookies so that we can remain authenticated).</p>
<p>Finally, for each message received from the WebSocket, we will simply write it
<em>on the fly</em> on the page.</p>
<p>The JavaScript code can be obtained in this way:</p>
<pre><code class="language-shell">$ opam install brr js_of_ocaml
$ ocamlfind c -linkpkg -package brr chat.ml
$ js_of_ocaml a.out -o chat.js
</code></pre>
<p>That's all we need on the client side. We will now return to Vif to:</p>
<ol>
<li>propose a <em>handler</em> to the WebSocket protocol</li>
<li>and create a new POST route to send messages</li>
</ol>
<h2 id="our-listeners-on-our-vif-server"><a class="header" href="#our-listeners-on-our-vif-server">Our listeners on our Vif server</a></h2>
<p>The idea behind our chatroom is quite simple. When someone connects to our
server via websocket, we create a <em>listener</em> in the sense that the client will
listen for any new messages.</p>
<p>This listener will be stored in a global value so that it can be retrieved from
any request handlers. As such, access must be protected so that this global
value is <em>domain-safe</em>.</p>
<p>There are three essential operations:</p>
<ol>
<li>create a listener</li>
<li>send a message to all listeners (i.e. all connected clients)</li>
<li>delete a listener</li>
</ol>
<pre><code class="language-ocaml">type chatroom =
  { make : unit -&gt; int * string Vif.Stream.source
  ; send : string -&gt; unit
  ; shutdown : int -&gt; unit }
;;

let chatroom =
  let uid = Atomic.make 0 in
  let actives = Hashtbl.create 0x100 in
  let mutex = Miou.Mutex.create () in
  let make () =
    let n = Atomic.fetch_and_add uid 1 in
    Miou.Mutex.protect mutex @@ fun () -&gt;
    let q = Vif.Stream.Bqueue.create 0x100 in
    Hashtbl.replace actives n q;
    n, Vif.Stream.Source.of_bqueue q in
  let shutdown uid =
    Miou.Mutex.protect mutex @@ fun () -&gt;
    Hashtbl.remove actives uid in
  let send msg =
    Miou.Mutex.protect mutex @@ fun () -&gt;
    let fn _ q = Vif.Stream.Bqueue.put q msg in
    Hashtbl.iter fn actives in
  let finally _ =
    Miou.Mutex.protect mutex @@ fun () -&gt;
    let fn _ q = Vif.Stream.Bqueue.close q in
    Hashtbl.iter fn actives in
  Vif.Device.v ~name:"chatroom" ~finally [] @@ fun _ -&gt;
  { make; send; shutdown }
;;
</code></pre>
<p>Here, we introduce two new concepts: a bounded queue and streams. We won't go
into detail about these modules, but they allow information to be transmitted
(and it's always <em>domain-safe</em>) between tasks. Conceptually, several tasks
(probably dispatched across several domains) will run to <em>listen</em> for any
messages we might want to send. A task will then appear that will execute the
handler for the POST request (allowing messages to be sent) and will have to
transmit this message to all active listeners (this is the purpose of the
<code>send</code> function).</p>
<p>Our chatroom, being global to our server, will be a device. We will then create
the WebSocket handler and a final route to be able to send messages.</p>
<h2 id="websocket"><a class="header" href="#websocket">Websocket</a></h2>
<p>The WebSocket protocol is a protocol that can be initiated from an HTTP
request. It involves creating a route and informing the client that we would
like to switch to the WebSocket protocol rather than HTTP, which is called an
<em>upgrade</em>. Vif allows you to attempt this upgrade. The client will then be
redirected to another handler, the WebSocket handler. This handler is special
because it no longer processes a request and provides a response, but works
with a stream of inputs (<code>ic</code>) and a stream of outputs (<code>oc</code>).</p>
<pre><code class="language-ocaml">let chat req server _ = Vif.Response.websocket ;;

let websocket ic oc server _ =
  let t = Vif.Server.device chatroom server in
  let uid, src = t.make () in
  let fn str = oc (`Msg (`Text, true), str) in
  let prm0 = Miou.async @@ fun () -&gt; Vif.Stream.Source.each fn src in
  let prm1 = Miou.async @@ fun () -&gt;
    let rec go () =
      match ic () with
      | None | Some (`Connection_close, _) -&gt; oc (`Connection_close, String.empty)
      | Some _ -&gt; go () in
    go () in
  let _ = Miou.await_first [ prm0; prm1 ] in
  t.shutdown uid
;;
</code></pre>
<p>Here, we introduce a few concepts related to Miou. When a client connects to
our websocket, the goal is to create tasks that will work together:</p>
<ol>
<li>one will consume everything the client can send (and it should not send
anything normally)</li>
<li>the other task will consist of transmitting messages from our <em>listener</em> to
our client</li>
</ol>
<p><code>Vif.Stream.Source.each</code> will execute <code>fn</code> as soon as the listener receives a
message, and <code>fn</code> will simply write this message to the client using <code>oc</code>.</p>
<p>One or both of these tasks will stop (because the client has disconnected or
because we want to shutdown the server). What is certain is that in any case,
everything must end. <code>Miou.await_first</code> will wait for one of the tasks and,
more importantly, will <em>cancel</em> the other. We can finally release the listener
resource correctly.</p>
<p>It may be interesting to look at Miou at this point and how it manages tasks.
We can recommend <a href="https://robur-coop.github.io/miou/">a short book</a> that explains in detail what a
scheduler looks like in OCaml 5 (with effects) and what Miou offers.</p>
<h2 id="send-a-message"><a class="header" href="#send-a-message">Send a message!</a></h2>
<p>Here, we will create a new handler, which will be our last one and will
summarise everything we have learned since the beginning of this short book. It
is a handler for a POST request in which we would have our message (<code>msg</code>). It
is still a question of whether the client is connected, and we will simply
prefix the message with the client's name.</p>
<pre><code class="language-ocaml">type msg = { msg : string } ;;

let msg =
  let open Vif.Multipart_form in
  let fn msg = { msg } in
  record fn
  |+ field "msg" string
  |&gt; sealr
;;

let send req server _ =
  let open Vif.Response.Syntax in
  match Vif.Request.of_multipart_form req, Vif.Request.get jwt req with
  | Ok { msg }, Some { username }-&gt;
    let t = Vif.Server.device chatroom server in
    let str = Fmt.str "%s: %s\n" username msg in
    t.send str;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let* () = Vif.Response.with_string req "Message sent!\n" in
    Vif.Response.respond `OK
  | Error _, _ -&gt;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let str = Fmt.str "Invalid multipart/form-data\n" in
    let* () = Vif.Response.with_string req str in
    Vif.Response.respond (`Code 422)
  | _, None -&gt;
    let* () = Vif.Response.add ~field:"content-type" "text/plain; charset=utf-8" in
    let* () = Vif.Response.with_string req "Unauthorized!" in
    Vif.Response.respond `Unauthorized
;;
</code></pre>
<p>Note that we are reusing our <code>chatroom</code> device here. This does not involve
creating a listener as in our WebSocket handler, but rather <em>broadcasting</em> the
message to all listeners.</p>
<h2 id="mix-them-all"><a class="header" href="#mix-them-all">Mix them all!</a></h2>
<p>We now need to properly configure our new <code>chatroom</code> device in Vif and give it
the handler for WebSocket connections:</p>
<pre><code class="language-ocaml">let routes =
  let open Vif.Uri in
  let open Vif.Route in
  let open Vif.Type in
  [ post (m login_form) (rel / "login" /?? nil) --&gt; login
  ; get (rel /?? nil) --&gt; index
  ; get (rel / "users" /?? nil) --&gt; users
  ; post (m login_form) (rel / "subscribe" /?? nil) --&gt; subscribe
  ; get (rel / "chat" /?? nil) --&gt; chat
  ; post (m msg) (rel / "send" /?? nil) --&gt; send ]
;;

let () =
  Miou_unix.run @@ fun () -&gt;
  Caqti_miou.Switch.run @@ fun sw -&gt;
  let uri = Uri.make ~scheme:"sqlite3" ~path:"vif.db" () in
  let env = { sw; uri; secret= "deadbeef" } in
  let middlewares = Vif.Middlewares.[ jwt ] in
  let handlers = [ Vif.Handler.static ?top:None ] in
  let devices = Vif.Devices.[ caqti; chatroom ] in
  Vif.run ~devices ~handlers ~middlewares ~websocket routes env
;;
</code></pre>
<p>There you go! You can now access the page <a href="http://localhost:8080/chat.html">http://localhost:8080/chat.html</a>
and, if you are logged in, you can send a message that others will be able to
read. It's a real chat room made with Vif.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Of course, there is room for improvement (starting with the design!). But the
bulk of the logic, the backend, is there. Despite Vif's minimalism, it is
possible to achieve satisfactory results fairly quickly.</p>
<p>Vif offers a way to develop websites with OCaml by taking up the idea of OCaml
scripts. Fortunately, this is not the central idea (note the use of effects
with Miou, the possibility of parallelising request management with OCaml 5,
etc.). The idea of scripting in OCaml is interesting because it requires very
little to get a website up and running.</p>
<p>Finally, Vif attempts to offer, at all levels of the HTTP protocol, a way of
typing information so that all checks can be performed upstream using DSLs such
as <code>jsont</code> or <code>caqti</code>. The idea is to really take advantage of the OCaml type
system (and see it more as an assistant rather than a constraint).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="a_persistent_userspace.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="memento.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="a_persistent_userspace.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="memento.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
